#encoding=utf-8
from __future__ import unicode_literals
from ctypes import *
import ctypes
import re
import os
from winappdbg import win32
#import pymdmp
import win32con
import win32api
import winerror
import sys
import gc
from ctypes import *
from time import time, sleep
from ctypes.wintypes import *
from threading import Thread
from struct import calcsize, pack, unpack, Struct
from win32gui import PyGetString, PySetString
from win32process import GetProcessMemoryInfo
from win32api import GetCurrentProcessId, GetCurrentProcess, CloseHandle
from win32con import MEM_FREE, PROCESS_VM_READ, PROCESS_VM_WRITE, PROCESS_QUERY_INFORMATION
from win32con import PAGE_READWRITE, PAGE_WRITECOPY, PAGE_EXECUTE_READWRITE, PAGE_EXECUTE_WRITECOPY
from win32con import PAGE_EXECUTE_READ, PAGE_READONLY, PROCESS_VM_OPERATION, PROCESS_ALL_ACCESS


def process_list():
    hProcessSnap = win32.CreateToolhelp32Snapshot()
    pe32 = win32.Process32First(hProcessSnap)
    if pe32 == None:
        print >> sys.stderr, "Failed getting first process."
        return
    while True:
        # szExeFile
        #    The name of the executable file for the process
        # https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/
        hProcess = -1
        try:
            hProcess = win32.OpenProcess(win32.PROCESS_QUERY_INFORMATION | win32.PROCESS_VM_READ,
                                         False, pe32.th32ProcessID)
        except:
            print "Get process handle FAILED:", ctypes.WinError()
        # if hProcess == ["Error 5", "Error 87"]:
        #     print "hProcess:", hProcess

        # print pe32.szExeFile
        # if pe32.th32ProcessID != 0 and pe32.th32ProcessID != 4:  # 0 - System Idle Process; 4 - System Process
        #     print "T process_list():", hProcess, pe32.th32ProcessID, pe32.szExeFile
        #     hProcess = win32.OpenProcess(win32.PROCESS_QUERY_INFORMATION | win32.PROCESS_VM_READ,
        #                               False, pe32.th32ProcessID)
        # else:
        #     hProcess = -1
        #     print "F process_list():", hProcess, pe32.th32ProcessID, pe32.szExeFile

        yield hProcess, pe32.th32ProcessID, pe32.szExeFile  # print pe32.szExeFile
        pe32 = win32.Process32Next(hProcessSnap)
        if pe32 == None:
            break

    # CloseHandle(hProcessSnap)

MEMORY_STATES = {0x1000: "MEM_COMMIT", 0x10000: "MEM_FREE", 0x2000: "MEM_RESERVE"}
MEMORY_PROTECTIONS = {0x10: "PAGE_EXECUTE", 0x20: "PAGE_EXECUTE_READ", 0x40: "PAGE_EXECUTE_READWRITE",
                      0x80: "PAGE_EXECUTE_WRITECOPY", 0x01: "PAGE_NOACCESS", 0x02: "PAGE_READONLY",
                      0x04: "PAGE_READWRITE", 0x08: "PAGE_WRITECOPY"}
MEMORY_TYPES = {0x1000000: "MEM_IMAGE", 0x40000: "MEM_MAPPED", 0x20000: "MEM_PRIVATE"}

class PyMEMORY_BASIC_INFORMATION:
    def __init__(self, MBI):
        self.MBI = MBI
        self.set_attributes()

    def set_attributes(self):
        self.BaseAddress = self.MBI.BaseAddress
        self.AllocationBase = self.MBI.AllocationBase
        self.AllocationProtect = MEMORY_PROTECTIONS.get(self.MBI.AllocationProtect, self.MBI.AllocationProtect)
        self.RegionSize = self.MBI.RegionSize
        self.State = MEMORY_STATES.get(self.MBI.State, self.MBI.State)
        # self.Protect = self.MBI.Protect  # uncomment this and comment next line if you want to do a bitwise check on Protect.
        self.Protect = MEMORY_PROTECTIONS.get(self.MBI.Protect, self.MBI.Protect)
        self.Type = MEMORY_TYPES.get(self.MBI.Type, self.MBI.Type)

def VirtualQueryEx(hProcess, lpAddress):
    _VirtualQueryEx = windll.kernel32.VirtualQueryEx
    _VirtualQueryEx.argtypes = [HANDLE, LPVOID, win32.PMEMORY_BASIC_INFORMATION, win32.SIZE_T]
    _VirtualQueryEx.restype  = win32.SIZE_T

    lpBuffer  = win32.MEMORY_BASIC_INFORMATION()
    dwLength  = sizeof(win32.MEMORY_BASIC_INFORMATION)
    success   = _VirtualQueryEx(hProcess, lpAddress, byref(lpBuffer), dwLength)
    if success == 0:
        raise ctypes.WinError()
    return PyMEMORY_BASIC_INFORMATION(lpBuffer)

def scan_page(process_handle, page_address):
    try:
        information = VirtualQueryEx(process_handle, page_address)
    except:
        print "VirtualQueryEx FAILED:", ctypes.WinError()
        return "", False, "", ""

    base_address = information.BaseAddress
    access_protection = information.Protect
    region_size = information.RegionSize
    next_region = base_address + region_size

    print "++++++++++++++++++++++++++++"
    print "access_protection:" + str(access_protection), "    base_address:" + str(hex(base_address))
    print "---------------------------------------------"

    if access_protection not in ["PAGE_EXECUTE_READWRITE"]:
        return next_region, False, "", ""
    else:
        return next_region, True, base_address, region_size

def scan_process(process_handle):
    """scans a processes pages for the target value."""
    si = win32.SYSTEM_INFO()
    psi = byref(si)
    windll.kernel32.GetSystemInfo(psi)
    # get the first address of the first page to scan so we know where to start scanning
    # A pointer to the lowest memory address accessible to applications and dynamic-link libraries (DLLs)
    base_address = si.lpMinimumApplicationAddress
    # get the last address to scan so we know when to stop scanning.
    # A pointer to the highest memory address accessible to applications and DLLs
    max_address = si.lpMaximumApplicationAddress
    # RWX_addreStorage = list()
    # RWX_sizeStorage = list()
    RWX_addreSizeDict = {}
    page_address = base_address

    #print "si.wProcessorArchitecture:" + str(si.wProcessorArchitecture)
    #print "base_address:" + str(base_address) + "   max_address:" + str(max_address)

    while page_address < max_address:
        next_page, found, RWX_address, RWX_regionSize = scan_page(process_handle, page_address)
        if found == True:
            print "FOUND RWX - ", hex(RWX_address)
            #RWX_addreSizeDict[hex(RWX_address)] = RWX_regionSize
            RWX_addreSizeDict[RWX_address] = RWX_regionSize
            # RWX_addreStorage.append(hex(RWX_address))
            # RWX_sizeStorage.append(RWX_regionSize)
        else:
            print ""
            #print "NOT found RWX"
        # found.extend(f)  # list.extend(seq) - Appends the contents of seq to list
        page_address = next_page

        # if len(RWX_storage) >= 60000000:
        #     print "[Warning] Scan ended early because too many addresses were found to hold the target data."
        #     break

    gc.collect()
    return RWX_addreSizeDict

def RECheckingDomain(content):
    urlFile = open('validUrls.txt', 'a')
    domainListFile = open('domainList.txt', 'r')
    domainList = []
    for domain in domainListFile:
        domainList.append(domain.rstrip())
    # url = open('url.txt', 'r')
    # content = url.read()
    #print "@@@" + content + "111"

    # ((http://|https://)?:\/\/(?:www\.|(?!www))[^\s\.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})
    reString = '(http://|https://)?([a-zA-Z0-9][a-zA-Z0-9\_\-]{1,62}\.)+([a-zA-Z\-]{2,})'# + ([^a-zA-Z0-9/\.]|\n|$)'
    # reString = '/^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9]\.[a-zA-Z]{2,}$/'
    reobj = re.compile(reString, re.IGNORECASE | re.MULTILINE)
    m = reobj.finditer(content)

    for i in m:
        print "+++compare+++"
        print i.group()
        print i.group(1), i.group(2), i.group(3)
        print "---compare---"

        TLD = (i.group(3)).upper()
        Valid = False
        for domain in domainList:
            # print "TLD:_" + TLD + "_"
            # print "domain:_" + domain + "_"
            if TLD == domain:
                Valid = True
                break

        if Valid == True:
            urlFile.write("Valid: " + i.group() + "\n")
            print "Valid: " + i.group()

    urlFile.close()

def dumpMemory(processInfoList):
    for proInfo in processInfoList:
        #foundPE = False
        PEaddress = []
        print "\n^^^^Check binary files^^^^^"
        print proInfo.processName, proInfo.processID
        #if proInfo.processName == "firefox.exe":
        #if proInfo.processID == 1956:

        # Check PE file
        for (address, size) in proInfo.processAddresses.items():
            print "\nAddress:", hex(address), "   Size:", size, "   Handle:", proInfo.processHandle
            #print win32.ReadProcessMemory(proInfo.processHandle, address, size)
            print "===Read the first two bytes to check if this is PE file==="
            data = win32.ReadProcessMemory(proInfo.processHandle, address, 2)
            if len(data) != 2:
                raise ctypes.WinError()
            else:
                if data[0]=='M' and data[1]=='Z':
                    urlFile = open('validUrls.txt', 'a')
                    urlFile.write("\n" + str(proInfo.processName) + " " + str(proInfo.processID) + "\n")
                    urlFile.close()

                    print "FOUND_PE==>"
                    #foundPE = True
                    PEaddress.append(address)
                    print data[0]
                    print data[1]
                    print "<=="

                    data = win32.ReadProcessMemory(proInfo.processHandle, address, size)
                    print "&&&&&&&&&"
                    #print data
                    print "#########"
                    RECheckingDomain(data)
                else:
                    print "NOT_PE==>"
                    print data
                    print "<=="
                # print data
            print "___END___\n"

        # if PE file found, then go to other regions
        if PEaddress:
            print "@@@@@@@@@@Found PE file, go to other regions@@@@@@@@"
            for (address, size) in proInfo.processAddresses.items():
                for addr in PEaddress:
                    if address == addr:
                        continue

                print "Inside other region"
                print "\nAddress:", hex(address), "   Size:", size, "   Handle:", proInfo.processHandle

                urlFile = open('validUrls.txt', 'a')
                urlFile.write("\n" + str(proInfo.processName) + " " + str(proInfo.processID) + "\n")
                urlFile.close()

                data = win32.ReadProcessMemory(proInfo.processHandle, address, size)
                print "&&&&&&&&&"
                #print data
                print "#########"
                RECheckingDomain(data)
            print "-------------------Found PE file, go to other regions-------------------"

        print "____Check binary files____\n"

# def dumpMemoryAPI(processInfoList):
#     dump(SEL_BY_PID, dumpMode, flags, [optionalArgs])

class processInfo:
    processHandle = ""
    processID = ""
    processName = ""
    processAddresses = None
    processAddressPerm = None

if __name__ == '__main__':
    if os.path.isfile('validUrls.txt'):
        os.remove("validUrls.txt")
    processInfoList = []

    for p in process_list():
        hProcess = p[0]
        processID = p[1]
        processName = p[2]
        print hProcess, processID, processName
        if hProcess == -1:
            continue

        print "\n+++process addresses+++"
        # addresses, sizes = scan_process(hProcess)
        addreSizeDict = scan_process(hProcess)
        # if addresses:
        if addreSizeDict:
            proIn = processInfo()
            proIn.processHandle = hProcess
            proIn.processID = processID
            proIn.processName = processName
            proIn.processAddresses = {}
            proIn.processAddresses = addreSizeDict
            processInfoList.append(proIn)

            print "***addresses result***"
            for (k, v) in  proIn.processAddresses.items():
                print "Address:", k, "   Size:", v
                # print proIn.processAddresses
            print "###addresses result###"
        # if processInfoList:
        #     print processInfoList[0].processID, processInfoList[0].processName, processInfoList[0].processAddresses
        print "---process addresses---\n"

    print "\n\n\n"
    dumpMemory(processInfoList)
    #dumpMemoryAPI(processInfoList)